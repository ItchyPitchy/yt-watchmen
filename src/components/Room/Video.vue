<script lang="ts">
  import { defineComponent, inject } from "vue";
  import { getDatabase, onValue, ref, set, update, type Unsubscribe } from "firebase/database";
  import type { Store } from "@/main";

  interface Room {
    host: string,
    name: string,
    videoId?: string,
    state: "playing" | "paused",
    time: number,
    rate: number,
  }

  interface Player {
    loadVideoById: (videoId: string, startSeconds?: number) => void,
    getPlayerState: () => PlayerState,
    pauseVideo: () => void,
    seekTo: (seconds: number, allowSeekAhead?: boolean) => void,
    getCurrentTime: () => number,
    playVideo: () => void,
    setPlaybackRate: (suggestedRate: number) => void,
  }

  enum PlayerState {
    UNSTARTED = -1,
    ENDED = 0,
    PLAYING = 1,
    PAUSED = 2,
    BUFFERING = 3,
    VIDEO_CUED = 5,
  }

  interface State {
    room: Room | null,
    autogeneratedMemberKey: string | null,
    unsubscribeOnValue: Unsubscribe | null,
    player: Player | null,
    videoUrlInput: string,
    done: boolean,
    updateTimeIntervalId: number | null,
  }

  const db = getDatabase()

  export default defineComponent({
    setup() {
      return {
        store: inject('store') as Store,
      }
    },
    data(): State {
      return {
        room: null,
        autogeneratedMemberKey: null,
        unsubscribeOnValue: null,
        player: null,
        videoUrlInput: "",
        done: false,
        updateTimeIntervalId: null,
      }
    },
    computed: {
      roomId() {
        return this.$route.params.id as string
      },
    },
    watch: {
      'roomId': {
        async handler(toId: string | undefined, fromId: string | undefined, cleanup) {
          if (this.unsubscribeOnValue) this.unsubscribeOnValue()


          console.log(toId, fromId)
          if (fromId) await this.removeUserFromRoom(fromId)
          if (toId) {
            const roomRef = ref(db, `rooms/${toId}`)

            this.unsubscribeOnValue = onValue(roomRef, (snapshot) => {
              const room = snapshot.val()

              console.log("roomchange", room)

              this.room = room
            })

            await this.addUserToRoom(toId)
          }

          cleanup(() => {
            if (this.unsubscribeOnValue) this.unsubscribeOnValue()
          })
        }
      },
      // 'room.videoId': {
      //   handler(videoId: string) {
      //     console.log("videoId", videoId)
      //     this.player?.loadVideoById(videoId, this.room?.time || 0)
      //   }
      // },
      // 'room.time': {
      //   handler(time) {
      //     console.log("time", time)
      //     this.player.seekTo(time)
      //   }
      // },
      // 'room.rate': {
      //   handler(rate: number) {
      //     console.log("rate", rate)
      //     this.player?.setPlaybackRate(rate)
      //   }
      // },
      'room': {
        handler(newRoomValue: Required<Room>, oldRoomValue: Room | null) {
          if (newRoomValue.videoId !== oldRoomValue?.videoId) this.player?.loadVideoById(newRoomValue.videoId, newRoomValue.time)

          if (newRoomValue.host === this.store.auth.userId) {
            if (this.updateTimeIntervalId === null) {
              this.updateTimeIntervalId = setInterval(() => {
                const roomRef = ref(db, `rooms/${this.roomId}`)

                update(roomRef, {
                  time: this.player?.getCurrentTime()
                })
              }, 5000)
            }
          } else {
            if (this.updateTimeIntervalId !== null) {
              clearInterval(this.updateTimeIntervalId)
              this.updateTimeIntervalId = null
            }
          }

          // Only react to room player updates if your not the host, i.e. the host leads
          if (newRoomValue.host !== this.store.auth.userId) {
            // Only host should update time
            if (this.updateTimeIntervalId !== null) clearTimeout(this.updateTimeIntervalId)

            console.log(newRoomValue.host, this.store.auth.userId)
            console.log("state", newRoomValue)

            if (oldRoomValue) {
              // If not paused to prevent calling seek event when host is just draggin the progress bar
              if (newRoomValue.state !== "paused") {
                if (Math.abs(newRoomValue.time - oldRoomValue.time) > 5) this.player?.seekTo(newRoomValue.time, true)
              }
            }

            if (newRoomValue.state !== oldRoomValue?.state) {
              switch(newRoomValue.state) {
                case "playing": {
                  this.player?.playVideo()
                  break
                }
                case "paused": {
                  this.player?.pauseVideo()
                  break
                }
                default: {
                  break
                }
              }
            }

            if (newRoomValue.rate !== oldRoomValue?.rate) this.player?.setPlaybackRate(newRoomValue.rate)
          }
        }
      },
    },
    beforeCreate() {
      window.onYouTubeIframeAPIReady = () => {
        this.initYoutube()
      }
    },
    created() {
      this.addUserToRoom(this.roomId)
    },
    mounted() {
      // This code loads the IFrame Player API code asynchronously.
      const exists = document.getElementById('youtubeIframeApi');

      if (!exists) {
        const tag = document.createElement('script');
        tag.src = "https://www.youtube.com/iframe_api";
        tag.id = 'youtubeIframeApi';
        const firstScriptTag = document.getElementsByTagName('script')[0] as HTMLScriptElement;
        firstScriptTag.parentNode!.insertBefore(tag, firstScriptTag);
      } else {
        this.initYoutube();
      }

    },
    methods: {
      async addUserToRoom(roomId: string) { // TODO: move to room component
        console.log("roomId", roomId)
        const userRef = ref(db, "users" + `/${this.store.auth.userId}`)

        await update(userRef, {
          room: roomId,
        })

        const roomMembersRef = ref(db, "rooms" + `/${roomId}/members`)

        await update(roomMembersRef, {
          [this.store.auth.userId!]: true,
        })
      },
      async removeUserFromRoom(roomId: string) { // TODO: move to room component
        const userRef = ref(db, "users" + `/${this.store.auth.userId}`)

        await update(userRef, {
          room: null
        })

        const roomMembersRef = ref(db, "rooms" + `/${roomId}/members`)

        await update(roomMembersRef, {
          [this.store.auth.userId!]: false,
        })
      },
      initYoutube() {
        const player = new window.YT!.Player('player', {
          height: '390',
          width: '640',
          videoId: null,
          playerVars: {
            'autoplay': 0,
            'playsinline': 1,
            'enablejsapi': 1,
          },
          events: {
            "onReady": this.onPlayerReady,
            "onStateChange": this.onPlayerStateChange,
            "onPlaybackRateChange": this.onPlayerPlaybackRateChange,
            "onError": (e: any) => console.log("error", e),
          },
        });

        this.player = player
      },
      async onPlayerReady() {
        // await event.target.loadVideoById(this.room.videoId)
        const roomRef = ref(db, `rooms/${this.roomId}`)

        this.unsubscribeOnValue = onValue(roomRef, (snapshot) => {
          const room = snapshot.val()

          console.log("roomchange", room)

          this.room = room
        })
        // event.target.playVideo()
      },
      onPlayerStateChange(event: { data: number }) {
        console.log(event.data)

        if (event.data === PlayerState.BUFFERING) return

        const roomRef = ref(db, "rooms" + `/${this.roomId}`)

        if (this.store.auth.userId === this.room?.host) {
          if (event.data === PlayerState.PLAYING) {
            update(roomRef, {
              state: "playing",
              time: this.player?.getCurrentTime()
            })
          } else if (event.data === PlayerState.PAUSED) {
            update(roomRef, {
              state: "paused",
              time: this.player?.getCurrentTime()
            })
          }
        }
        // if (event.data == window["YT"].PlayerState.PLAYING && !this.done) {
        //   setTimeout(this.stopVideo, 6000)
        //   this.done = true
        // }
      },
      onPlayerPlaybackRateChange(event: { data: number }) {
        const roomRef = ref(db, `rooms/${this.roomId}`)

        update(roomRef, {
          rate: event.data,
        })
      },
      async loadVideo() {
        const url = new URL(this.videoUrlInput)
        const urlParams = new URLSearchParams(url.search)

        if (urlParams.has("v")) {
          const videoId = urlParams.get("v")

          const roomVideoIdRef = ref(db, `rooms/${this.roomId}/videoId`)

          await set(roomVideoIdRef, videoId)

          // this.player?.loadVideoById(videoId)
        }
      },
    }
  })
</script>

<template>
  <input v-model="videoUrlInput" placeholder="video url here"/>
  <button @click="loadVideo">Load video</button>
  <div id="player"></div>
  <router-link to="/rooms/4">Go to other Id</router-link>
</template>

<style>

</style>
